import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:build/build.dart';

class StringResBuilder implements Builder {
  StringResBuilder(BuilderOptions options) {
    final inputPath = options.config["input_path"] as Map?;
    stringResPathMap = inputPath?.map((key, value) => MapEntry(key as String, value as String));
    genCodeDir = options.config["output_dir"] as String? ?? "lib/res_gen/";
    defaultLang = options.config["default_lang"] as String? ?? "en";
    assert(stringResPathMap?[defaultLang] != null, "there is no path for default language");

    if (!genCodeDir.endsWith("/")) {
      genCodeDir += "/";
    }
  }

  /// The strings resource paths for multi-language.
  /// The key is country code, the value is strings resource path.
  late final Map<String, String>? stringResPathMap;

  /// The directory for generated code
  late String genCodeDir;

  /// The default language
  late final String defaultLang;

  /// The generated code file name for string res keys.
  final String stringResKeyFileName = "string_res_key";

  final String stringResFileName = "string_res";

  @override
  Future<void> build(BuildStep buildStep) async {
    // every json file in the string resources paths will go here, but only generate
    // code for default language.
    if (buildStep.inputId.path == stringResPathMap?[defaultLang]) {
      await generateStringResKey(buildStep);
      await generateStringRes(buildStep);
    }
  }

  Future<void> generateStringResKey(BuildStep buildStep) async {
    final messages = (json.decode(await buildStep.readAsString(buildStep.inputId)) as Map)
        .cast<String, String>();

    final outputBuffer = StringBuffer("// Generated by the string resources builder. DO NOT EDIT!\n\n");
    outputBuffer.writeln("class StringResKey {");
    messages.forEach((key, value) {
    outputBuffer.writeln('  static const String $key = "$key";');
    });
    outputBuffer.writeln("}");

    final genFile = File(genCodeDir + stringResKeyFileName + buildExtensions[buildStep.inputId.extension]!.first);
    final isExist = await genFile.exists();
    if (!isExist) {
      await genFile.create(recursive: true);
    }
    await genFile.writeAsString(outputBuffer.toString());
  }

  String getSupportLanguage() {
    final outputBuffer = StringBuffer("{\n");
    stringResPathMap?.forEach((key, value) {
      outputBuffer.writeln('    "$key": "$value",');
    });
    outputBuffer.write("  }");
    return outputBuffer.toString();
  }

  Future<void> generateStringRes(BuildStep buildStep) async {
    String output = '''
import 'dart:convert';
import 'dart:io';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:sprintf/sprintf.dart';

class StringRes {
  StringRes._internal();
  
  factory StringRes.getInstance() => _instance;
  
  static late final StringRes _instance = StringRes._internal();

  // the string resources absolute path for the target language
  String? _targetStringResAbsolutePath;
  // the string resources path for the target language, which is in assets
  String _defaultStringResPath = "${buildStep.inputId.path}"; 

  Map<dynamic, dynamic>? _targetStringRes;
  Map<dynamic, dynamic>? _defaultStringRes;
  
  Map<String, String> _supportLanguages = ${getSupportLanguage()};

  Future<void> load({String? targetStringResAbsolutePath}) async {
    if (_defaultStringRes == null) {
      _defaultStringRes = await _loadStringResByAssets(_defaultStringResPath);
    }

    if (_targetStringRes == null || _targetStringResAbsolutePath != targetStringResAbsolutePath) {
      _targetStringResAbsolutePath = targetStringResAbsolutePath;
      _targetStringRes = await _loadStringResByAbsolutePath(absolutePath: _targetStringResAbsolutePath);
    }
  }

  dynamic _loadStringResByAssets(String? assetsPath) async {
    if (assetsPath == null) {
      return {};
    }
    
    try {
      final String jsonStr = await rootBundle.loadString(assetsPath);
      final dynamic ret = json.decode(jsonStr);
      return ret;
    } on Exception catch (e) {
      debugPrint("parse default string res failed, \${e.toString()}");
      return {};
    }
  }
  
  Future<dynamic> _loadStringResByAbsolutePath({String? absolutePath}) async {
    if (absolutePath == null) {
      final ret = await _loadStringResByAssets(_supportLanguages[window.locale.languageCode]);
      return ret;
    }
    
    final file = File(absolutePath);
    if (file.existsSync()) {
      try {
        final String jsonStr = await file.readAsString();
        final dynamic ret = json.decode(jsonStr);
        return ret;
      } on Exception catch (e) {
        debugPrint("parse target string res failed, \${e.toString()}");
        return {};
      }
    }
  }

  String _getString(String key, { List<dynamic>? params }) {
    final String? text = _targetStringRes?[key] ?? _defaultStringRes?[key];
    return text == null ? key : (params == null ? text : sprintf(text, params));
  }
  
  static String getString(String key, { List<dynamic>? params }) {
    return StringRes.getInstance()._getString(key, params: params);
  }
}
    ''';
    final genFile = File(genCodeDir + stringResFileName + buildExtensions[buildStep.inputId.extension]!.first);
    final isExist = await genFile.exists();
    if (!isExist) {
      await genFile.create(recursive: true);
    }
    await genFile.writeAsString(output.toString());
  }

  @override
  final buildExtensions = const {
    ".json": [".g.dart"]
  };

}