import 'dart:async';
import 'dart:io';
import 'package:mime/mime.dart';
import 'package:build/build.dart';
import 'package:path/path.dart' as path;

class ImageResBuilder implements Builder {
  ImageResBuilder(BuilderOptions options) {
    imageDir = List.from(options.config["image_dir"]);
    genCodeDir = options.config["output_dir"] as String? ?? "lib/res_gen/";

    if (!genCodeDir.endsWith("/")) {
      genCodeDir += "/";
    }

    Future(() async {
      await _genImageCode();
    });
  }

  /// The asset image resources directory.
  late List<String> imageDir;

  /// The directory for generated code
  late String genCodeDir;

  @override
  Future<void> build(BuildStep buildStep) async {}

  @override
  Map<String, List<String>> get buildExtensions => {};

  Future<void> _genImageCode() async {
    print("image_res_builder: $imageDir");

    Map<String, String> imageList = {};
    Map<String, String> animationList = {};
    for (final dir in imageDir) {
      String tmpDir = dir;
      if (!tmpDir.endsWith("/")) {
        tmpDir += "/";
      }

      final rootDir = Directory(tmpDir);
      if (!rootDir.existsSync()) {
        continue;
      }

      List<FileSystemEntity> fileList = rootDir.listSync();
      for (FileSystemEntity entity in fileList) {
        if (FileSystemEntity.typeSync(entity.path) !=
            FileSystemEntityType.file) {
          continue;
        }

        switch (lookupMimeType(entity.path)) {
          case 'image/jpeg':
          case 'image/png':
          case 'image/bmp':
            imageList[path.basenameWithoutExtension(entity.path)] = entity.path;
            break;
          case 'image/gif':
          case 'image/webp':
            animationList[path.basenameWithoutExtension(entity.path)] =
                entity.path;
            break;
          default:
            break;
        }
      }
    }

    final outputBuffer = StringBuffer('''
// Generated by the image resources builder. DO NOT EDIT!

import 'package:flutter/widgets.dart';

''');
    outputBuffer.writeln('''
class _AssetsGenImages {
  const _AssetsGenImages();
''');
    imageList.forEach((key, value) {
      outputBuffer.writeln(
          '  AssetGenImage get ${_formatImgKeyName(key)} => const AssetGenImage("$value");');
    });
    outputBuffer.writeln("}");

    outputBuffer.writeln('''

class _AssetsGenAnimations {
  const _AssetsGenAnimations();
''');
    animationList.forEach((key, value) {
      outputBuffer.writeln(
          '  AssetGenImage get ${_formatImgKeyName(key)} => const AssetGenImage("$value");');
    });
    outputBuffer.writeln("}");

    outputBuffer.writeln('''

class Assets {
  Assets._();

  static const _AssetsGenImages images = _AssetsGenImages();
  static const _AssetsGenAnimations animations = _AssetsGenAnimations();
}

class AssetGenImage extends AssetImage {
  const AssetGenImage(String assetName) : super(assetName);
  
  String get path => assetName;
}  
''');
    final genFile = File("${genCodeDir}image_res.g.dart");
    final isExist = await genFile.exists();
    if (!isExist) {
      await genFile.create(recursive: true);
    }
    await genFile.writeAsString(outputBuffer.toString());
  }

  String _formatImgKeyName(String fileName) {
    final _symbols = [
      ' ',
      '.',
      '/',
      '_',
      '\\',
      '-',
      '@',
    ];
    final _upperAlphaRegex = RegExp(r'[A-Z]');
    final _lowerAlphaRegex = RegExp(r'[a-z]');
    final buffer = StringBuffer();
    final words = <String>[];

    for (var i = 0; i < fileName.length; i++) {
      final char = String.fromCharCode(fileName.codeUnitAt(i));
      final nextChar = i + 1 == fileName.length
          ? null
          : String.fromCharCode(fileName.codeUnitAt(i + 1));

      if (_symbols.contains(char)) {
        continue;
      }

      buffer.write(char);

      final isEndOfWord = nextChar == null ||
          (_upperAlphaRegex.hasMatch(nextChar) &&
              fileName.contains(_lowerAlphaRegex)) ||
          _symbols.contains(nextChar);

      if (isEndOfWord) {
        words.add(buffer.toString());
        buffer.clear();
      }
    }

    final wordsTmp = words
        .map((w) =>
            '${w.substring(0, 1).toUpperCase()}${w.substring(1).toLowerCase()}')
        .toList();
    wordsTmp[0] = wordsTmp[0].toLowerCase();
    return wordsTmp.join();
  }
}
